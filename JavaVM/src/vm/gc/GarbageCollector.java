package vm.gc;

public class GarbageCollector {
    /**
     * 垃圾收集器
     *
     * 新生代：
     *  1.新生代串行收集器，使用复制算法
     *
     *  2.ParNew收集器，类似于串行收集器，但是在进行垃圾收集的时候是多线程进行的
     *
     *  3.新生代ParallelGC收集器
     *
     * 老年代：
     *  1.老年代串行收集器
     *
     *  2.ParallelOldGC收集器：采用标记压缩算法
     *
     *  3.CMS收集器（Concurrent Mark Sweep），主要关注系统的停顿时间，CMS收集器不是独占式，其垃圾收集可以和用户代码同时进行
     *  在老年代的使用率达到一定比率的时候CMS收集器会开始进行垃圾回收。CMS的缺点在于会产生内存碎片（但是可以通过设置参数使得其
     *  能够在收集完成之后进行碎片整理）
     *  一次CMS的gc会产生2次full gc（因为full gc的次数等于老年代STW的次数，但实际上CMS和full gc关系不大，因为full gc是在老年代空间
     *  不足的情况下触发的，如果CMS执行期间发生了老年代不足的情况，那么就直接转入full gc）
     *  启动CMS：-XX：+UseConcMarkSweepGC
     *  CMS的过程：
     *      1.初始标记（STW）
     *      2.并发标记
     *      3.预清理 该阶段会等待minor gc以减小对下一阶段的影响
     *      4.重新标记（STW）该阶段会扫描整个堆来判断对象存活（因为存在新生代的对象对老年代的对象引用的情况，也就是"跨代引用"，所以
     *      连同新生代也需要扫描，所以为了减小新生代扫描，上一步会等待一个minor gc）
     *      5.并发清理
     *      6.并发重置
     *
     * 新生代&老年代：
     *  g1收集器，使用-XX：+UseG1GC。g1兼具了上述垃圾收集器的诸多优点：并行性（垃圾收集时多条线程运行），并发性（用户代码和gc交替进行），
     *  分代gc（新生代和老年代），空间整理（不会出现内存碎片），分区回收
     *  g1的过程：
     *      1.新生代gc
     *      2.并发标记周期
     *          初始标记（STW），标记从根节点可达的对象。该过程伴随一次minor gc，因此是独占式的
     *          根区域扫描，该过程会扫描由survivor区域可达的老年代区域（也就是survivor区的对象引用的老年代对象所处的区域）
     *          并发标记
     *          重新标记（STW），对标记结果进行修正
     *          独占清理（STW），实际上这一步不会清理，而是标记出需要被混合收集的区域
     *          并发清理，识别并清理完全空闲的区域
     *      3.混合收集，即收集垃圾比率最高的区域
     *      4.如果需要，则进行full gc
     *
     */

    /**
     * 串行收集器：
     * 单线程
     * 独占式（这意味着收集器的线程在工作的时候，用户代码是停止的）（STW）
     */

    /**
     * 吞吐量：CPU用于运行用户代码的时间与CPU总的运行时间的比值
     * 并行收集器的特点就是非常关注吞吐量
     * -XX:MaxGCPauseMillis 设置最大垃圾收起停顿时间
     * -XX:GCTimeRatio 设置程序运行时间和gc时间的比率
     */
}
